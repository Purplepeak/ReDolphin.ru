Вообще, более-менее нормально. Вот небольшие замечания: 

> Если так, то проблема в том, что моя библиотека отрезает от ссылки на картинку все, кроме названия файла. 
> То есть мне нужно переделать код библиотеки миниатюр
Ну видимо придется переделать. Потому что посуди сам, что это за библиотека которая может создавать превьюшки только в одной директории? Нужно решение поуниверсальнее. Кстати, еще хорошо бы хранить превьюшки в твой же папке что и файл, чтобы их удалять проще было.

> Алсо посмотри проверку загруженного файла:
Надо еще проверять что файл вообще есть, то есть !empty($_FILES['userfile']['tmp_name']). Это может быть если файл не выбран, а форма отправлена.

> php_value upload_max_filesize 60M
Было бы здорово если твое приложение само определяло максимально допустимый размер файла (брало минимум из настрокек + конфига) и выводило около формы загрузки файла. Ну если сложно, можешь не делать определение а просто прописать в конфиге число.

> file_name
> link
А почему часть полей с префиксом file а часть без? Неаккуратно как-то.

> } catch (UploadException $e) {
> echo $e->getMessage();
Не, нужно не так, а выводить форму загрузки + текст ошибки (для выделения текста ошибки в bootstrap есть штука: http://getbootstrap.com/components/#alerts )

> 'scale'
Логично сделать это константой: Thumbnail::TYPE_SCALE

> public function saveData() {
> $data = array('id' => $this->id, 
Если ты хочешь обновить существующий файл, надо делать не INSERT а UPDATE.

> public function formatBytes() 
Такие вещи логично помещать в другой класс, Util::formatByteCount() или Helper::formatByteCount().



Замечания, часть 2/2.

> if(($thumbWidth === 100 && $thumbHeight === 100) || ($thumbWidth === 200 && $thumbHeight === 200) || ($thumbWidth === 250 && $thumbHeight === 250) || ($thumbWidth === 130 && $thumbHeight === 200))
Э, не, так не пойдет. Чтобы поменять список размеров, придется переписывать код. Это нужно вынести в отдельную внешнюю настройку, например так: 

Thumbnail::setAllowedSizes(....);

(кстати, почему у нас это класс со статическими методами? Не получится же создать 2 класса с разными настройками).

> if (getimagesize($file->link)) {
> Thumbnail::getResizedImage($file->link, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, "scale", $file->name);
Э не, это кривой код. Функция getResizedImage() среди прочего может вывести всякие заголовки, и так вызывать ее не стоит. Логично тогда сделать функцию вроде Thumbnail::generatePreviewImage(...)

> PHP-расширение остановило загрузку файла.
> Не удалось записать файл на диск.
Это хорошее сообщение для записи в лог-файл (хотя тогда стоило бы и подробности добавить), но плохое сообщение для показа пользователю. Пользователь-то исправить это пробелму все равно не может. Лучше писать что-то вроде «Не удалось загрузить файл из-за проблем на нашем сервере. Вы можете попробовать сделать это еще раз.»

> Максимальный размер загружаемого файла: 60 Mb
Эту цифру стоит везде брать из конфига, а то надо менять тексты в нескольких местах.

> <?php if (getimagesize($fileData->link)): ?>
Э не, этого в шаблоне не должно быть. В шаблоне можно сделать так: if ($file->hasThumbnail()): 





Ты эту страницу читал: http://www.php.net/manual/ru/features.file-upload.common-pitfalls.php ? Там несколько настроек есть которые могут влиять.

> ничего не происходит и выскакивает пустая страница
Я подозреваю, выход за пределы памяти

> Проблема начинается, когда я пытаюсь загрузить файл, например, весом 1,5 ГБ. Пока файл не загрузится никаких сообщений выводится не будет и сайт просто виснет на время загрузки.
Да, твой скрипт запустится только после того как обработаны пришедшие данные и все файлы сохранены. 

Если ты хочешь, то проще сделать проверку при выборе файла яваскриптом. В новых браузерах (список http://caniuse.com/#feat=fileapi ) ты можешь получить информацию о выбранном файле в момент его выбора (ну а пользователи старых — что поделать, будут ждать полной загрузки). Вот как это делается: http://i.ndigo.com.br/2012/01/javascipt-checking-the-file-size/ (там в коде нет проверок на тип барузера. Сначала надо проверить что у тебя есть доступ к свойству this.files, если нет — мы в старом браузере, и только потом выполнять код).